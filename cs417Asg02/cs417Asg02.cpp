// cs417Asg02.cpp

#include <iostream>
#include <queue>
#include <memory>
#include <stdexcept>
using namespace std;

template<typename T>
class Node {
public:
	int key;
    T data;
    Node* left = nullptr;
    Node* right = nullptr;

    Node() {}
    Node(T inputData, int inputKey) : data(inputData), key (inputKey) {}
};

template<typename T>
class Tree {
private:
    Node<T>* root = nullptr;

    Node<T>* copyTree(Node<T>* node) {
        if (!node) return nullptr;
        Node<T>* newNode = new Node<T>(node->data, node->key);
        newNode->left = copyTree(node->left);
        newNode->right = copyTree(node->right);
        return newNode;
    }

    void deleteTree(Node<T>* node) {
        if (!node) return;
        deleteTree(node->left);
        deleteTree(node->right);
        delete node;
    }

public:
    Tree() {}

    Tree(T input) {
        root = new Node<T>(input);
    }

    Tree(const Tree& other) {
        root = copyTree(other.root);
    }

    ~Tree() {
        deleteTree(root);
    }
	
	//Generated by Grok
	Node<T>* findNodeRec(int key, Node<T>* node) {
		if (!node) return nullptr;
		if (node->key == key) return node;
		Node<T>* left = findNodeRec(key, node->left);
		if (left) return left;
		return findNodeRec(key, node->right);
	}
	//Generated by Grok
	T findKey(int key) {
		if (!root) throw std::runtime_error("Empty Tree.");
		Node<T>* n = findNodeRec(key, root);
		if (!n) throw std::runtime_error("Key not found.");
		return n->data;
	}

    void insertNode(T inputData, int inputKey) {
        Node<T>* node = new Node<T>(inputData, inputKey);
        if (root == nullptr) {
            root = node;
            return;
        }
        queue<Node<T>*> q;
        q.push(root);
        while (!q.empty()) {
            Node<T>* current = q.front();
            q.pop();
            if (current->left == nullptr) {
                current->left = node;
                return;
            }
            else if (current->right == nullptr) {
                current->right = node;
                return;
            }
            else {
                q.push(current->left);
                q.push(current->right);
            }
        }
    }

    void deleteNode(T input) {
        if (root == nullptr) {
            return;
        }
        if (root->data == input) {
            deleteTree(root);
            root = nullptr;
            return;
        }
        queue<Node<T>*> q;
        q.push(root);
        while (!q.empty()) {
            Node<T>* current = q.front();
            q.pop();
            if (current->left) {
                if (current->left->data == input) {
                    deleteTree(current->left);
                    current->left = nullptr;
                }
                else {
                    q.push(current->left);
                }
            }
            if (current->right) {
                if (current->right->data == input) {
                    deleteTree(current->right);
                    current->right = nullptr;
                }
                else {
                    q.push(current->right);
                }
            }
        }
    }

    void inOrderRec(Node<T>* current) {
        if (current == nullptr) {
            return;
        }
        inOrderRec(current->left);
        cout << current->data << endl;
        inOrderRec(current->right);
    }

    void postOrderRec(Node<T>* current) {
        if (current == nullptr) {
            return;
        }
        postOrderRec(current->left);
        postOrderRec(current->right);
        cout << current->data << endl;
    }

    void preOrderRec(Node<T>* current) {
        if (current == nullptr) {
            return;
        }
        cout << current->data << endl;
        preOrderRec(current->left);
        preOrderRec(current->right);
    }

    void inOrder() {
        inOrderRec(root);
    }

    void postOrder() {
        postOrderRec(root);
    }

    void preOrder() {
        preOrderRec(root);
    }
};

int main() {
    Tree<string> indexList;
	string inputStr, outputStr;
	int inputInt;

	do
	{
		cout << "Enter a Number for the index card:\n";
		cin >> inputInt;
		cout << "Enter the text for the index card:\n";
		cin >> inputStr;
		indexList.insertNode(inputStr, inputInt);

		cout << "Continue? (Y/N) \n";
		cin >> inputStr;
	} while (inputStr != "N" && inputStr != "n");
    

	cout << "Enter a key: \n";
	cin >> inputInt;

	outputStr = indexList.findKey(inputInt);
	cout << outputStr << endl;


}



/*
Code debugged using Grok. original Code before Debugging:
#include <iostream>
#include<queue>
#include<memory>
using namespace std;

template<typename t>
class Node
{
public:
	t data;
	Node* left = nullptr;
	Node* right = nullptr;

	Node() {}
	Node(t input) : data(input) {}
};

template<typename t>
class Tree
{
private:
	Node* root;


public:

	Tree()
	{

	}
	//From Grok
	Tree(T input)
	{
		root = make_unique<Node<t>>(input);
	}
	//From Grok
	Tree(const Tree& other)
	{
		if (other.root)
		{
			root = make_unique<Node>(other.root->data);
			// Implement recursive copy for left and right subtrees
		}
	}

	bool findKey(t key)
	{
		if (root == nullptr)
		{
			return false
		}

		bool found = false;
		found = findKeyRec(key, root);


		return found;
	}


	bool findKeyRec(t key, Node* node)
	{
		if (node == nullptr)
		{
			return false;
		}

		else if (node->data == key)
		{
			return true;
		}

		else//Sourced from GeekForGeeks at https://www.geeksforgeeks.org/cpp/binary-tree-in-cpp/
		{
			return findKeyRec(key, node->left) || findKeyRec(key, node->right);
		}

	}


	//Based on code from https://www.geeksforgeeks.org/cpp/binary-tree-in-cpp/
	void insertNode(t input)
	{
		Node* node(input);
		if (root == nullptr)
		{
			root = node;
		}
		else
		{
			queue<Node*> q;
			q.push(root);

			while (!q.empty())
			{
				Node* current = q.front();
				q.pop();

				if (current->left == nullptr)
				{
					current->left = node;
				}
				else if (current->right == nullptr)
				{
					current->right = node;
				}
				else
				{
					q.push(current->left);
					q.push(current->right);
				}
			}
		}
	}

	void deleteNode(t input)
	{
		if (root == nullptr)
		{
			return;
		}
		else
		{
			queue<Node*> q;
			q.push(root);

			while (!q.empty())
			{
				Node* current = q.front();
				q.pop();

				if (current->left->data == input)
				{
					current->left = nullptr;
				}
				else if (current->right->data == input)
				{
					current->right = nullptr;
				}
				else
				{
					q.push(current->left);
					q.push(current->right);
				}
			}
		}

	}


	void inOrderRec(Node* current)
	{
		if (current == nullptr)
		{
			return;
		}

		inOrderRec(current->left);
		cout << current->data << endl;
		inOrderRec(current->right);
	}

	void postOrderRec(Node* current)
	{
		if (current == nullptr)
		{
			return;
		}

		postOrderRec(current->left);
		postOrderRec(current->right);
		cout << current->data << endl;
	}

	void preOrderRec(Node* current)
	{
		if (current == nullptr)
		{
			return;
		}


		cout << current->data << endl;
		preOrderRec(current->left);
		preOrderRec(current->right);
	}


	void inOrder()
	{
		inOrderRec(root);
	}

	void postOrder()
	{
		postOrderRec(root);
	}

	void preOrder()
	{
		preOrderRec(root);
	}

};




int main()
{
	Tree<int> testTree(1);
	testTree.insertNode(2);
	bool found = testTree.findKey(1);
	cout << found << endl;
	testTree.inOrder();
	testTree.postOrder();
	testTree.preOrder();




}

*/